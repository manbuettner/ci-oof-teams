// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import React from 'react';
import { ChoiceGroup } from 'office-ui-fabric-react/lib/ChoiceGroup';
import axios from 'axios';
import * as microsoftTeams from "@microsoft/teams-js";


import DatePane from './DatePane/DatePane';
import Aux from '../hoc/Auxillary/Auxillary';
import classes from './Tab.module.css';
import { Checkbox, Stack, themeRulesStandardCreator } from '@fluentui/react';
import UserInformation from './UserInformation/UserInformation';
import { Avatar, Button, Loader } from '@fluentui/react-northstar'
import jwtDecode from 'jwt-decode';
import CIUser from '../classes/CIUser';
import DelegateInformation from './DelegateInformation/DelegateInformation';



/**
 * The 'PersonalTab' component renders the main tab content
 * of your app.
 */
class OoFTeams extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      context: {},
      ssoToken: "",
      name: "",
      givenName: "",
      family_name: "",
      aadObjectId: "",
      upn: "",
      consentRequired: false,
      consentProvided: false,
      graphAccessToken: "",
      photo: "",
      error: false,
      loggedInUser: null,
      delegateUser: null,
      isOutofOffice: ""


    }

    this.unhandledFetchError = this.unhandledFetchError.bind(this);
    this.ssoLoginSuccess = this.ssoLoginSuccess.bind(this);
    this.ssoLoginFailure = this.ssoLoginFailure.bind(this);
    this.consentSuccess = this.consentSuccess.bind(this);
    this.consentFailure = this.consentFailure.bind(this);
    this.unhandledFetchError = this.unhandledFetchError.bind(this);
    this.callGraphFromClient = this.callGraphFromClient.bind(this);
    this.showConsentDialog = this.showConsentDialog.bind(this);
    this.exchangeClientTokenForServerToken = this.exchangeClientTokenForServerToken.bind(this);
    this.requestUserInformations = this.requestUserInformations.bind(this);
  }

  //React lifecycle method that gets called once a component has finished mounting
  //Learn more: https://reactjs.org/docs/react-component.html#componentdidmount
  componentDidMount() {
    microsoftTeams.initialize();

    // Get the user context from Teams and set it in the state
    microsoftTeams.getContext((context, error) => {
      this.setState({ context: context });


      // if (this.state.customerBookings === null) {
      //   const requestData = {
      //     "webcode": "ciazure",
      //     "sEmail": username,
      //     "language": "en"
      //   }
      //   axios.post("https://cloud.ci-solution.com/api/GetCustomerBookings", requestData)
      //     .then(response => {
      //       this.setState({ customerBookings: response.data })
      //     })
      // }

    });

    let authenTokenRequestsOptions = {
      successCallback: (result) => this.ssoLoginSuccess(result),
      failureCallBack: (error) => this.ssoLoginFailure(error)
    };

    microsoftTeams.authentication.getAuthToken(authenTokenRequestsOptions);

  }

  componentDidUpdate = async (prevProps, prevState) => {
    //Check to see if a Graph access token is now in state AND that it didn't exist previously
    if ((prevState.graphAccessToken === "") && (this.state.graphAccessToken !== "")) {
      //this.callGraphFromClient();
    }
  }

  // shouldComponentUpdate(nextProps, nextState) {
  //   return nextState.ssoToken !== this.state.ssoToken;
  // }

  ssoLoginSuccess = async (token) => {
    this.setState({ ssoToken: token });

    let decodedToken = jwtDecode(token);

    this.setState({
      name: decodedToken.name,
      aadObjectId: decodedToken.oid,
      upn: decodedToken.upn,
      tenantId: decodedToken.tid,
      given_name: decodedToken.given_name,
      family_name: decodedToken.family_name
    });

    this.exchangeClientTokenForServerToken(token);
  }



  ssoLoginFailure(error) {
    console.error("SSO failed: ", error);
    this.setState({ error: true });
  }

  exchangeClientTokenForServerToken = async (token) => {
    const ApiData = {
      "webcode": "ciazure",
      "sEmail": this.state.context["upn"],
      "language": "en"
    }

    let response = await fetch('https://localhost:44381/api/GetMSGraphAccessToken', {
      method: "POST",
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(ApiData)
    })
      .catch(this.unhandledFetchError); //This calls getGraphAccessToken route in /api-server/app.js
    let data = await response.json().catch(this.unhandledFetchError);

    //TODO: response.ok wieder einfÃ¼gen
    if (!response.ok) {
      console.log(data);
      this.setState({ error: true });
    } else {
      this.setState({ graphAccessToken: data['access_token'] });
      this.requestUserInformations(data["access_token"])
    }
  }

  requestUserInformations = async (accessToken) => {
    let upn = this.state.context["upn"];
    let userContent = `https://graph.microsoft.com/v1.0/users/${upn}`   

    let graphRequestParams = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        "authorization": "bearer " + this.state.graphAccessToken
      }
    }

    let responseUser = await fetch(userContent, graphRequestParams).catch(this.unhandledFetchError);
    let dataUser = await responseUser.json().catch(this.unhandledFetchError);

    

    if (!responseUser.ok) {
      console.log(dataUser);
      this.setState({ error: true });
    } else {
      const cCIUser = new CIUser(dataUser);
      this.setState({
        loggedInUser: cCIUser
      })
    }
    
  }


  showConsentDialog() {
    microsoftTeams.authentication.authenticate({
      url: window.location.origin + "/auth-start",
      width: 600,
      height: 535,
      successCallback: (result) => { this.consentSuccess(result) },
      failureCallback: (reason) => { this.consentFailure(reason) }
    });
  }

  consentSuccess(result) {
    this.setState({
      graphAccessToken: result,
      consentProvided: true
    });
  }

  consentFailure(reason) {
    console.error("Consent failed: ", reason);
    this.setState({ error: true });
  }


  callGraphFromClient = async () => {
    let upn = this.state.context["upn"];
    if (upn === "r.lawo@dokmgm.de") {
      upn = "m.buettner@dokmgm.de";
    }
    let graphPhotoEndpoint = `https://graph.microsoft.com/v1.0/users/${upn}/photo/$value`;
    let graphRequestParams = {
      method: 'GET',
      headers: {
        'Content-Type': 'image/jpg',
        "authorization": "bearer " + this.state.graphAccessToken
      }
    }

    let response = await fetch(graphPhotoEndpoint, graphRequestParams).catch(this.unhandledFetchError);
    if (!response.ok) {
      console.error("ERROR: ", response);
      this.setState({ error: true });
    }

    let imageBlog = await response.blob().catch(this.unhandledFetchError);

    this.setState({
      photo: URL.createObjectURL(imageBlog)
    })
  }

  unhandledFetchError(error) {
    console.error("Unhandled fetch error: ", error);
    this.setState({ error: true });
  }



  onChangeStatusHandler = (ev, checked) => {
    this.setState({ isOutofOffice: checked.key });
  }

  deputySearchHandler =async (delegateName) => {
    console.log("DelegateName: " , delegateName);

    let delegateContent = `https://graph.microsoft.com/v1.0/users/${delegateName}`;
    let graphRequestParams = {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        "authorization": "bearer " + this.state.graphAccessToken
      }
    }

    let responseDelegate = await fetch(delegateContent, graphRequestParams).catch(this.unhandledFetchError);
    let dataDelegate = await responseDelegate.json().catch(this.unhandledFetchError);

    if (!responseDelegate.ok) {
      console.log(dataDelegate);
      this.setState({ error: true });
    } else {
      const cCIUser = new CIUser(dataDelegate);
      this.setState({
        delegateUser: cCIUser
      })
    }
  }



  render() {
    

    const oofStatus = [
      { key: 'A', text: 'In Office', checked: true },
      { key: 'B', text: 'Out of Office' }
    ];

    let title = Object.keys(this.state.context).length > 0 ?
      'Congratulations ' + this.state.context["upn"] + '! This is your tab' : <Loader />

    let ssoMessage = this.state.ssoToken === "" ?
      <Loader label='Performing single sign-on authentication...' /> : null;

    let ssoOutput = this.state.ssoToken === "" ?
      null
      : <>
        <p>Token: {this.state.ssoToken}</p>
        <p>Now let's use the token's data:</p>
        <p>
          name: <span>{this.state.name}</span><br />
        aadObjectId: <span>{this.state.aadObjectId}</span><br />
        upn: <span>{this.state.upn}</span><br />
        tenantId: <span>{this.state.tenantId}</span><br />
        </p>
      </>;

    let serverExchangeMessage = (this.state.ssoToken !== "") ?
      <Loader label='Exchanging SSO access token for Graph access token...' /> : null;

    // let constentButton = (this.state.consentRequired && !this.state.consentProvided) ?
    //   <Loader label="Constent required" onClick={this.showConsentDialog} /> : null;

    let avatar = this.state.photo !== "" ?
      <Avatar image={this.state.photo} size="largest" /> : null;

    let userInformations = (this.state.loggedInUser !== null) ?
      <UserInformation
        givenName={this.state.loggedInUser.givenName}
        sn={this.state.loggedInUser.sn}
        email={this.state.loggedInUser.email}
        onChangeStatus={(ev, checked) => this.onChangeStatusHandler(ev, checked)}
        oofStatus={oofStatus}
      /> : <Loader />

    let delegateInformations = (this.state.loggedInUser !== null) ?
      <DelegateInformation 
        searchHandler={this.deputySearchHandler}
      /> : <Loader />


    let content;
    if (this.state.error) {
      content = <h1>ERROR</h1>
    } else {
      content =
        <div >
          <h1>{title}</h1>
          <h3>{ssoMessage}</h3>
          <h3>{ssoOutput}</h3>
          {/* <h3>{serverExchangeMessage}</h3> */}
          {delegateInformations}
        </div>
    }  



    

    return (
      <div>
        {userInformations}
        {delegateInformations}

        {/* {content} */}
      </div>
    );




    // let username = Object.keys(this.state.context).length > 0 ? this.state.context["upn"] : "";

    // const registerdOptions = [
    //   {key: 'A', text: 'In Office', checked: true },
    //   {key: 'B', text: 'Out of Office' }
    // ];

    // if (this.state.customerBookings) {
    //   registerdOptions[0].checked = this.state.customerBookings.hasCIOof;
    // }

    // const onChange = (event, checked) => {
    //   this.setState({ scheduledOOF: !!checked });
    // }


    //return (


    // <div>
    //   <h3>Hello World!</h3>
    //   <h1>Congratulations {userName}!</h1> <h3>This is the tab you made :-)</h3>
    //   <ChoiceGroup options={registerdOptions} label="Registered State" />

    // </div>
    //   <Aux>
    //     <Stack >
    //       <Stack.Item align="center">
    //         <h1 style={{ textAlign: "center" }}>Welcome {username}</h1>
    //       </Stack.Item>
    //     </Stack>
    //     <Stack horizontal disableShrink tokens={aligmentsStackTokensTop}>
    //       <Stack.Item align="start">
    //         <DatePane />
    //       </Stack.Item>
    //       <Stack.Item align="start">
    //         <ChoiceGroup options={registerdOptions} label="Registered State" />
    //         <Checkbox className={classes.CheckboxOOF} label="Scheduled out of office" checked={this.state.scheduledOOF} onChange={onChange} />
    //       </Stack.Item>
    //     </Stack>
    //     <Stack>
    //       <Stack.Item align="center" tokens={aligmentsStackTokens}>
    //         <AppointmentList />
    //       </Stack.Item>
    //     </Stack>
    //   </Aux>
    // );
  }
}

const aligmentsStackTokens = {
  childrenGap: 5,
  padding: 10,
};

const aligmentsStackTokensTop = {
  childrenGap: 40,
  padding: 25
}
export default OoFTeams;